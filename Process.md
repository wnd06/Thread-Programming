![](https://raw.githubusercontent.com/nhnacademy-bootcamp/java-thread-programming/689b48726478b78bffe92df19bec7f75fadf4805/doc/1.process_vs_thread/image/process_vs_thread2.svg?token=ASZDETL45L4H5DCYIK3HXO3FFTN7C)

- 실행 중인 프로그램을 의미한다.
- [[스케줄링]]의 대상이 되는 작업(task)과 같은 의미로 쓰인다.
- [[Storage]]의 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고 할당된 메모리 공간으로 바이너리 코드가 올라간다.
	- 이 순간 부터 process라고 불린다. (ready -> running)
- Process는 하나 이상의 스레드 구성이 된다.


#### 프로세스 구성
- 프로세스 제어블록(PCB) 또는 프로세스 기술자 라고 부르는 자료구조에 저장된다.

### 프로세스 관리
- 운영체제는 프로세스들의 실행 사이에 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 관리해야 한다.
- 운영체제는 프로세스의 상태를 실행, 준비, 블록 상태로 분류하고 프로세스들을 State transition(상태전이)를 통해 체계적으로 관리한다.

- ![](https://velog.velcdn.com/images/jhon3242/post/732f103d-5790-4899-9d23-9bc107d47ff4/image.png)
1.  사용자가 프로그램을 실행하면 프로세스가 생성되고 준비 리스트에 추가가 된다. 프로세스는 프로세서가 사용가능한 상태가 되면 CPU를 할당 받는다. 이를 준비 상태에서 실행 상태로 상태전이 된다고 한다.
	- 이 과정을 Dispatching(디스 패칭)이라고 하고, 디스패처(dispatcher)가 이 일을 수행한다.

2. 이제 프로세스는 실행상태에서 CPU를 이용하면서 연산한 후 CPU를 자발적으로 반납하고 작업이 끝나지 않았으면 다시 준비 상태에 들어가게 된다. -> 이러한 과정을 반복한다.

3. 만약 프로세스가 다시 사용하기 전에 입출력을 받아야 하는 상황이라면 입출력이 완료 될 때 까지 자신을 블록 한다. 입출력이 완료되면 운영체제가 프로세스를 준비 상태로 다시 전이 시키게 된다.


### 프로세스의 한계

- 기술이 발전함에 따라 프로그램이 복잡해지고 다채로워짐으로써 프로세스 작업 하나만을 사용해서 프로그램을 실행하기에는 한계가 있다.
- 동일한 프로그램을 여러 개의 프로세스로 만들게 되면, 그만큼 메모리를 차지하고 CPU에서 할당 받는 자원이 중복되게 될 것이다.
	- 그래서 해결책으로 [[Thread]]가 탄생하였다.


### 프로세스의 특징

1. 프로그램이 실행하기 위한 모든 자원들을 개별적으로 가지고 있어 무겁다.
2. process 별로 자체 메모리를 갖는다.
3. 개별 메모리로 인해 process간 통신이 느리다.
4. 메모리에 있던 정보를 storage에 옮기거나 storage에 저장된 정보를 메모리에 올리는 작업이 수행되므로 비용이 많이 든다.
5. 구성 요소에 대한 여러 process가 있는 application은 메모리가 부족할 때 더 나은 메모리 활용도를 제공할 수 있다.